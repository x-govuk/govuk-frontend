{"version":3,"file":"index.mjs","sources":["../../../src/govuk/common/index.mjs"],"sourcesContent":["/**\n * Common helpers which do not require polyfill.\n *\n * IMPORTANT: If a helper require a polyfill, please isolate it in its own module\n * so that the polyfill can be properly tree-shaken and does not burden\n * the components that do not need that helper\n *\n * @module common/index\n */\n\n/**\n * Config flattening function\n *\n * Takes any number of objects, flattens them into namespaced key-value pairs,\n * (e.g. \\{'i18n.showSection': 'Show section'\\}) and combines them together, with\n * greatest priority on the LAST item passed in.\n *\n * @private\n * @returns {{ [key: string]: unknown }} A flattened object of key-value pairs.\n */\nexport function mergeConfigs (/* configObject1, configObject2, ...configObjects */) {\n  /**\n   * Function to take nested objects and flatten them to a dot-separated keyed\n   * object. Doing this means we don't need to do any deep/recursive merging of\n   * each of our objects, nor transform our dataset from a flat list into a\n   * nested object.\n   *\n   * @param {{ [key: string]: unknown }} configObject - Deeply nested object\n   * @returns {{ [key: string]: unknown }} Flattened object with dot-separated keys\n   */\n  const flattenObject = function (configObject) {\n    // Prepare an empty return object\n    /** @type {{ [key: string]: unknown }} */\n    const flattenedObject = {}\n\n    /**\n     * Our flattening function, this is called recursively for each level of\n     * depth in the object. At each level we prepend the previous level names to\n     * the key using `prefix`.\n     *\n     * @param {Partial<{ [key: string]: unknown }>} obj - Object to flatten\n     * @param {string} [prefix] - Optional dot-separated prefix\n     */\n    const flattenLoop = function (obj, prefix) {\n      // Loop through keys...\n      for (const key in obj) {\n        // Check to see if this is a prototypical key/value,\n        // if it is, skip it.\n        if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n          continue\n        }\n        const value = obj[key]\n        const prefixedKey = prefix ? `${prefix}.${key}` : key\n        if (typeof value === 'object') {\n          // If the value is a nested object, recurse over that too\n          flattenLoop(value, prefixedKey)\n        } else {\n          // Otherwise, add this value to our return object\n          flattenedObject[prefixedKey] = value\n        }\n      }\n    }\n\n    // Kick off the recursive loop\n    flattenLoop(configObject)\n    return flattenedObject\n  }\n\n  // Start with an empty object as our base\n  /** @type {{ [key: string]: unknown }} */\n  const formattedConfigObject = {}\n\n  // Loop through each of the remaining passed objects and push their keys\n  // one-by-one into configObject. Any duplicate keys will override the existing\n  // key with the new value.\n  for (let i = 0; i < arguments.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- Ignore mismatch between arguments types\n    const obj = flattenObject(arguments[i])\n    for (const key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        formattedConfigObject[key] = obj[key]\n      }\n    }\n  }\n\n  return formattedConfigObject\n}\n\n/**\n * Extracts keys starting with a particular namespace from a flattened config\n * object, removing the namespace in the process.\n *\n * @private\n * @param {{ [key: string]: unknown }} configObject - The object to extract key-value pairs from.\n * @param {string} namespace - The namespace to filter keys with.\n * @returns {{ [key: string]: unknown }} Flattened object with dot-separated key namespace removed\n * @throws {Error} Config object required\n * @throws {Error} Namespace string required\n */\nexport function extractConfigByNamespace (configObject, namespace) {\n  // Check we have what we need\n  if (!configObject || typeof configObject !== 'object') {\n    throw new Error('Provide a `configObject` of type \"object\".')\n  }\n\n  if (!namespace || typeof namespace !== 'string') {\n    throw new Error('Provide a `namespace` of type \"string\" to filter the `configObject` by.')\n  }\n\n  /** @type {{ [key: string]: unknown }} */\n  const newObject = {}\n\n  for (const key in configObject) {\n    // Split the key into parts, using . as our namespace separator\n    const keyParts = key.split('.')\n    // Check if the first namespace matches the configured namespace\n    if (Object.prototype.hasOwnProperty.call(configObject, key) && keyParts[0] === namespace) {\n      // Remove the first item (the namespace) from the parts array,\n      // but only if there is more than one part (we don't want blank keys!)\n      if (keyParts.length > 1) {\n        keyParts.shift()\n      }\n      // Join the remaining parts back together\n      const newKey = keyParts.join('.')\n      // Add them to our new object\n      newObject[newKey] = configObject[key]\n    }\n  }\n  return newObject\n}\n"],"names":["mergeConfigs","flattenObject","configObject","flattenedObject","flattenLoop","obj","prefix","key","Object","prototype","hasOwnProperty","call","value","prefixedKey","formattedConfigObject","i","arguments","length","extractConfigByNamespace","namespace","Error","newObject","keyParts","split","shift","newKey","join"],"mappings":"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"}